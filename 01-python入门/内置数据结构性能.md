## python内置数据结构性能分析

### 列表实现原理

列表是以**数组**（Array）实现的，这个数组是 **over-allocate** 数组。顾名思义，当底层数组容量满了而需要扩充的时候，python依据规则会扩充多个位置出来。比如初始化列表array=[1, 2, 3, 4]，向其中添加元素23，此时array对应的底层数组，扩充后的容量不是5，而是8。这就是over-allocate的意义，即扩充容量的时候会多分配一些存储空间。如图1，展示了`l.insert(1,5)` 的操作。

[![图1. insert操作](https://article-shaw.oss-cn-beijing.aliyuncs.com/img/2020/61/1.png)](https://article-shaw.oss-cn-beijing.aliyuncs.com/img/2020/61/1.png)

这里说下，列表的增长模式为：0，4，8，16，25，35，46，58，72，88…
![img](https://img2020.cnblogs.com/blog/1220254/202004/1220254-20200428115201664-2037400622.png)

#### 列表函数讲解

- append()方法是指在列表末尾增加一个数据项，这里的表强调的是插入1个元素，即没有扩容。
- extend()方法是指在列表末尾增加一个数据集合；
- insert()方法是指在某个特定位置前面增加一个数据项，需要移动其他元素位置；
- len()方法获取列表内元素的个数，因为在列表实现中，其内部维护了一个 `Py_ssize_t` 类型的变量表示列表内元素的个数，因此时间复杂度为O(1)；
- sort()方法是排序，网上有原理讲解，使用的是 **Timesort** 排序，该排序结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法，它在现实中有很好的效率。空间复杂度为O(n)。其排序的过程大致为，对输入的数字进行分区，然后再进行合并；

#### 性能分析

列表不太适合做元素的**查找**、**删除**、**插入**等操作，因为这些都要遍历列表，对应的时间复杂度为O(n)

访问某个**索引**的元素、**尾部**添加元素(append)或删除(pop last)元素这些操作比较适合用列表做，对应的时间复杂度为O(1)。

根据官方上说，列表最大的开销发生在**超过了当前所分配的列表大小**，这是因为，所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动。如果你需要在一个队列的两端进行增删的操作，应当使用`collections.deque`。

如果我们要在业务开发中，判断一个value是否在一个数据集中，如果数据集用列表存储，那此时的判断操作就很耗时，如果我们用hash table（set or dict）来存储，则比较轻松。

### Dict

1. 字典的底层实现是哈希表
2. 字典是无序的，但可以使用collections.OrderedDict()实现有序字典。OrderedDict的实现原理是哈希表+双链表
3. 字典的增删改查都是O(1)的时间复杂度
   ![img](https://img2020.cnblogs.com/blog/1220254/202004/1220254-20200428115240238-2021318238.png)

### Set

1. 集合的底层实现是哈希表
2. 集合的增删改查与字典一样，都是O(1)的时间复杂度
   ![img](https://img2020.cnblogs.com/blog/1220254/202004/1220254-20200428115334011-873074353.png)

### collections.deque

1. 双向队列的底层实现是双链表
2. 一种对列表的改进：在头尾的增删都是O(1)的时间复杂度
3. 但是在队列中的增删仍是O(n)的时间复杂度
4. 查找也是O(n)的时间复杂度
   ![img](https://img2020.cnblogs.com/blog/1220254/202004/1220254-20200428115409902-1187041683.png)