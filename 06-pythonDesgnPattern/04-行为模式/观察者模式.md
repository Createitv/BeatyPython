# 观察者模式

**观察者模式（Observer Pattern）**：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish / Subscribe）模式、模型-视图（Model / View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

![观察模式](https://typora-1300715298.cos.ap-shanghai.myqcloud.com/uPic/image-20210615191852133.png)

- **解决问题**：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作
- **何时使用**：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知
- **如何解决**：使用面向对象技术，可以将这种依赖关系弱化
- **核心代码**：在抽象类里有一个 ArrayList 存放观察者们
- **应用实例**：
  - 拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。
  - 面试的时候，完事之后每个面试官都会对我说：“请留下你的联系方式， 有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。所以我不用每天或者每小时都去询问面试结果， 通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。
- **优点**：
  - 观察者和被观察者是抽象耦合的
  - 建立一套触发机制
- **缺点**：
  - 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
  - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
  - 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
- **使用场景**：
  - 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
  - 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
  - 一个对象必须通知其他对象，而并不知道这些对象是谁。
  - 需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。

## 结构

观察者模式包含如下角色：

- Subject（目标）：知道它的通知对象，事件发生后会通知所有它知道的对象，提供添加删除观察者的接口。
- ConcreteSubject（具体目标）：被观察者具体的实例，存储观察者感兴趣的状态。
- Observer（观察者）：提供通知后的更新事件。
- ConcreteObserver（具体观察者）：被观察者具体的实例，存储观察者感兴趣的状态。

